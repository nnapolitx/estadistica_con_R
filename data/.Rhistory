library(datasets)  # Load base packages manually
# Installs pacman ("package manager") if needed
if (!require("pacman")) install.packages("pacman")
# Use pacman to load add-on packages as desired
pacman::p_load(pacman, psych)
head(iris)
# Get info on package
p_help(psych)           # Opens package PDF in browser
p_help(psych, web = F)  # Opens help in R Viewer
describe(iris$Sepal.Length)  # One quantitative variable
describe(iris)               # Entire data frame
# Clear environment
rm(list = ls())
# Clear packages
p_unload(all)  # Remove all add-ons
detach("package:datasets", unload = TRUE)   # For base
# Clear console
cat("\014")  # ctrl+L
library(datasets)  # Load base packages manually
# Installs pacman ("package manager") if needed
if (!require("pacman")) install.packages("pacman")
# Use pacman to load add-on packages as desired
pacman::p_load(pacman, tidyverse)
# Use pacman to load add-on packages as desired
pacman::p_load(pacman, tidyverse)
?mtcars
head(mtcars)
cars <- mtcars[, c(1:4, 6:7, 9:11)]  # Select variables
head(cars)
# Save hierarchical clustering to "hc." This codes uses
# pipes from dplyr.
hc <- cars   %>%  # Get cars data
dist   %>%  # Compute distance/dissimilarity matrix
hclust      # Computer hierarchical clusters
plot(hc)          # Plot dendrogram
plot(hc)          # Plot dendrogram
rect.hclust(hc, k = 2, border = "gray")
rect.hclust(hc, k = 3, border = "blue")
rect.hclust(hc, k = 4, border = "green4")
rect.hclust(hc, k = 5, border = "darkred")
# Clear environment
rm(list = ls())
# Clear packages
p_unload(all)  # Remove all add-ons
detach("package:datasets", unload = TRUE)  # For base
# Clear plots
dev.off()  # But only if there IS a plot
# Clear console
cat("\014")  # ctrl+L
library(datasets)  # Load base packages manually
# Installs pacman ("package manager") if needed
if (!require("pacman")) install.packages("pacman")
# Use pacman to load add-on packages as desired
pacman::p_load(pacman, rio)
# From the official R documentation
browseURL("http://j.mp/2aFZUrJ")
# CSV
rio_csv <- import("~/r-projects/feecodecamp-r-tutorial/ImportingData_Datasets/mbb.csv")
head(rio_csv)
# TXT
rio_txt <- import("~/r-projects/feecodecamp-r-tutorial/ImportingData_Datasets/mbb.txt")
head(rio_txt)
# Excel XLSX
rio_xlsx <- import("~/r-projects/feecodecamp-r-tutorial/ImportingData_Datasets/mbb.xlsx")
head(rio_xlsx)
?View
View(rio_csv)
# Load a spreadsheet that has been saved as tab-delimited
# text file. Need to give complete address to file. This
# command gives an error on missing data but works on
# complete data.
r_txt1 <- read.table("~/Desktop/mbb.txt", header = TRUE)
# This works with missing data by specifying the separator:
# \t is for tabs, sep = "," for commas. R converts missing
# to "NA"
r_txt2 <- read.table("~/Desktop/mbb.txt",
header = TRUE,
sep = "\t")
# CSV FILES
# Don't have to specify delimiters for missing data
# because CSV means "comma separated values"
trends.csv <- read.csv("~/Desktop/mbb.csv", header = TRUE)
# Clear environment
rm(list = ls())
# Clear packages
p_unload(all)  # Remove all add-ons
# Clear console
cat("\014")  # ctrl+L
# Packages I load every time; uses "pacman"
pacman::p_load(pacman, dplyr, GGally, ggplot2, ggthemes,
ggvis, httr, lubridate, plotly, rio, rmarkdown, shiny,
stringr, tidyr)
library(datasets)  # Load base packages manually
# Installs pacman ("package manager") if needed
if (!require("pacman")) install.packages("pacman")
# Use pacman to load add-on packages as desired
pacman::p_load(pacman, caret, lars, tidyverse)
?USJudgeRatings
head(USJudgeRatings)
data <- USJudgeRatings
# Define variable groups
x <- as.matrix(data[, -12])
y <- data[, 12]
# Using variable groups
reg1 <- lm(y ~ x)
# Or specify variables individually
reg1 <- lm(RTEN ~ CONT + INTG + DMNR + DILG + CFMG +
DECI + PREP + FAMI + ORAL + WRIT + PHYS,
data = USJudgeRatings)
# Results
reg1           # Coefficients only
summary(reg1)  # Inferential tests
anova(reg1)            # Coefficients w/inferential tests
coef(reg1)             # Coefficients (same as reg1)
confint(reg1)          # CI for coefficients
resid(reg1)            # Residuals case-by-case
hist(residuals(reg1))  # Histogram of residuals
# Clear environment
rm(list = ls())
# Clear packages
p_unload(all)  # Remove all add-ons
detach("package:datasets", unload = TRUE)  # For base
# Clear plots
dev.off()  # But only if there IS a plot
# Clear console
cat("\014")  # ctrl+L
# NXN 13/03/2022
# Estadistica descriptiva
mean(c(2, 3))
mean(2:10)
sd(c(2,3))
sd(2:3)
metallica <- c("Lars", "James", "Jason", "Kirk")
metallica2 <- metallica[metallica!='Jason']
soda <- c('cerati', 'zeta', 'charly')
soda[1]
sodaAge <- c(22, 23, 25)
sodaDataFrame <- data.frame(soda, sodaAge, sodacolor)
sodacolor <- c('blue' 'white' 'yellow')
sodaDataFrame <- data.frame(soda, sodaAge, sodacolor)
sodaAge <- c(22, 23, 25)
sodacolor <- c('blue' 'white' 'yellow')
sodaDataFrame <- data.frame(soda, sodaAge, sodacolor)
sodaColor <- c("blue", "white", "yellow")
sodaDataFrame <- data.frame(soda, sodaAge, sodacolor)
sodaDataFrame <- data.frame(soda, sodaAge, sodaColor)
sodaDataFrame
sodaDataFrame <- data.frame(Name = soda, Age = sodaAge, Color = sodaColor)
sodaDataFrame
# 3.8 Transform data
satisfactionData <- read.csv("Honeymoon_Period.csv")
getwd()
# can also set a directory with setwd()
setwd("/home/nick/utalca/estadistica_con_R/data")
getwd()
# 3.8 Transform data
satisfactionData <- read.csv("Honeymoon_Period.csv")
satisfactionData
head(satisfactionData)
head(satisfactionData)
# Esta data frame la podemos a transformar a un formato long usando
# la función stack.
satisfy_Stacked <- stack(satisfactionData,
select = c("Satisfaction_Base",
"Satisfaction_6_Months",
"Satisfaction_12_Months",
"Satisfaction_18_Months"))
colnames(satisfactionStacked) <- c("Values", "SatisfType")
colnames(satisfy_Stacked) <- c("Values", "SatisfType")
# cambiamos los encabezados
head(satisfy_Stacked)
# Otra manera de transformar datos a formato long es usando
# la función melt. Para ello necesitamos cargar la librería reshape.
library(reshape)
restructData <- melt(satisfactionData,
id = c("Person", "Gender"),
measured = c("Satisfaction_Base",
"Satisfaction_6_Months",
"Satisfaction_12_Months",
"Satisfaction_18_Months"))
colnames(restructData)[3:4] <- c("SatisfType", "Values") #Change labels
head(restructData)
# Use the order() method to reorder data
orderedData <- restructData[order(restructData$Person),]
orderedData
wideData <- cast(restructData, Person + Gender ~ SatisfType, value = "Values")
head(wideData)
# 3.7
# Uno de los aspectos fundamentales de esta manipulación es la selección
# de datos. Primero, importemos alguna base de datos.
lectData <- read.csv('lecturer_data.csv')
lectData
lectData$job <- factor(lectData$job,
levels = c(1:2),
labels = c('Lecturer', 'Student'))
lectData
onlyLecturer <- lectData[lectData$job == 'Lecturer',]
# the comma is required after lecturer
onlyLecturer
LecturersThatDrinkLeast <- onlyLecturer[onlyLecturer$alcohol <= 15,]
LecturersThatDrinkLeast
# 3.8 Transform data
satisfactionData <- read.csv("Honeymoon_Period.csv")
head(satisfactionData)
# Esta data frame la podemos a transformar a un formato long usando
# la función stack.
satisfy_Stacked <- stack(satisfactionData,
select = c("Satisfaction_Base",
"Satisfaction_6_Months",
"Satisfaction_12_Months",
"Satisfaction_18_Months"))
colnames(satisfy_Stacked) <- c("Values", "SatisfType")
# cambiamos los encabezados
head(satisfy_Stacked)
# 3.9 Exporting Data
getwd()
# 3.9 Exporting Data
write.table(LecturersThatDrinkLeast, "datos_exportados.txt", sep = "\t")
# 3.10 Pactice
library(ggplot2)
latidos <- read.csv("latidos_cardiacos.csv", header = TRUE)
latidos
mean(latidos$latidos)
sd(latidos$latidos)
h1 <- ggplot(latidos, aes(latidos))
h1 + geom_histogram()
